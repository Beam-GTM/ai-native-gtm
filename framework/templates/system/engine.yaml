# Engine Component Template
# Version: 1.0.0
# Purpose: Standard template for creating executable engine components
# Pattern: Templates + Indices + Engines = Complete Executable Systems

template:
  name: "engine-component"
  version: "1.0.0"
  type: "system-component"
  description: "Creates executable engine component from the Interactive Engine Architecture pattern"
  category: "implementation-layer"
  
  # Based on proven interactive-engine.md success:
  # - 80% memory reduction
  # - 70% performance improvement
  # - Clean separation of concerns

# TEMPLATE VARIABLES
variables:
  # Core Identity
  engine_name: "{{ENGINE_NAME}}"           # e.g., "interactive", "workflow", "validation"
  engine_id: "{{ENGINE_ID}}"               # e.g., "interactive-001", "workflow-exec-001"
  component_type: "{{COMPONENT_TYPE}}"     # e.g., "menu-system", "workflow-orchestration"
  
  # Integration
  template_refs: "{{TEMPLATE_REFERENCES}}" # Which templates this engine populates
  index_refs: "{{INDEX_REFERENCES}}"       # Which indices this engine reads from
  
  # Implementation
  state_types: "{{STATE_TYPES}}"           # Supported state types (e.g., "template", "critical", "clean")
  execution_modes: "{{EXECUTION_MODES}}"   # How engine can be invoked
  
  # Performance
  cache_strategy: "{{CACHE_STRATEGY}}"     # session | persistent | none
  lazy_loading: "{{LAZY_LOADING}}"         # true | false
  fallback_behavior: "{{FALLBACK_MODE}}"   # graceful | static | error

# TEMPLATE STRUCTURE
structure: |
  <!-- version: 3.2.0 -->
  <!-- engine_type: {{COMPONENT_TYPE}} -->
  <!-- engine_id: {{ENGINE_ID}} -->
  <!-- last_modified: {{TIMESTAMP}} -->
  
  # {{ENGINE_NAME}} Engine
  **Engine Type**: {{COMPONENT_TYPE}} Implementation Layer  
  **Engine ID**: {{ENGINE_ID}}  
  **Purpose**: {{ENGINE_DESCRIPTION}}  
  **Pattern**: Templates + Indices + Engines Architecture

  ## ðŸ”´ ENGINE ACTIVATION DIRECTIVE
  **CRITICAL**: This engine component contains executable logic - DO NOT document, EXECUTE immediately
  
  ## Engine Interface Implementation
  
  ### Core Methods (Required)
  ```yaml
  engine_interface:
    execute:
      description: "Main execution logic - implement the core engine functionality"
      parameters: 
        - context: "Current system context"
        - inputs: "Input parameters from calling system"
      returns: "Processed results"
      implementation: |
        # IMPLEMENTATION LOGIC GOES HERE
        # Based on proven pattern from interactive-engine.md
        # 1. Validate inputs
        # 2. Detect current state
        # 3. Execute appropriate logic
        # 4. Return processed results
    
    detect_state:
      description: "State detection algorithm - determine current system state"
      parameters:
        - system_context: "Current system context"
        - loaded_components: "Available components"
      returns: "Detected state (e.g., template, critical, clean)"
      implementation: |
        # STATE DETECTION LOGIC
        # Analyze system conditions
        # Return appropriate state identifier
    
    populate_content:
      description: "Dynamic content population - fill templates with live data"
      parameters:
        - template_structure: "Template to populate"
        - dynamic_data: "Live system data"
      returns: "Populated template"
      implementation: |
        # CONTENT POPULATION LOGIC
        # Replace placeholders with actual values
        # Apply formatting and optimization
    
    process_input:
      description: "User input processing - handle user interactions"
      parameters:
        - user_input: "User command or selection"
        - current_state: "System state context"
      returns: "Processed action or routing decision"
      implementation: |
        # INPUT PROCESSING LOGIC
        # Parse user intent
        # Route to appropriate handler
        # Return action specification
    
    optimize:
      description: "Performance optimization - enhance execution efficiency"
      parameters:
        - execution_metrics: "Current performance data"
      returns: "Optimization results"
      implementation: |
        # OPTIMIZATION LOGIC
        # Apply caching strategies
        # Implement lazy loading
        # Return performance improvements
  
  ### Optional Methods
  ```yaml
  optional_methods:
    elicit:
      description: "Progressive context gathering for complex scenarios"
      enabled: {{ELICITATION_ENABLED}}
      implementation: |
        # ELICITATION LOGIC (if needed)
        
    cache:
      description: "State caching for performance"
      strategy: "{{CACHE_STRATEGY}}"
      implementation: |
        # CACHING LOGIC
        
    validate:
      description: "Input/output validation"
      enabled: true
      implementation: |
        # VALIDATION LOGIC
        
    fallback:
      description: "Error recovery and graceful degradation"
      mode: "{{FALLBACK_MODE}}"
      implementation: |
        # FALLBACK LOGIC
  ```
  
  ## Integration Configuration
  
  ### Template Integration
  ```yaml
  template_integration:
    references: {{TEMPLATE_REFERENCES}}
    placeholder_pattern: "{{PATTERN}}"
    bidirectional_flow: true
    population_method: "populate_content"
  ```
  
  ### Index Integration  
  ```yaml
  index_integration:
    references: {{INDEX_REFERENCES}}
    rule_query_method: "query_rules"
    state_mapping: "detect_state"
    routing_logic: "process_input"
  ```
  
  ### System Integration
  ```yaml
  system_integration:
    loading: "{{LAZY_LOADING}}"
    caching: "{{CACHE_STRATEGY}}"
    fallback: "{{FALLBACK_MODE}}"
    error_handling: "graceful"
    
    activation_triggers:
      - "{{ACTIVATION_CONDITIONS}}"
    
    performance_targets:
      memory_reduction: "70%"
      speed_improvement: "60%"
      load_time: "<100ms"
  ```
  
  ## Implementation Example
  
  ### Proven Pattern (from interactive-engine.md)
  ```yaml
  success_example:
    component: "menu-system"
    results:
      memory_reduction: "80%"
      performance_improvement: "70%"
      integration: "seamless"
      maintainability: "excellent"
    
    pattern_application:
      templates: "menu-template files"
      indices: "menu-index.md (rules)"
      engine: "interactive-engine.md (this component)"
      result: "Complete executable menu system"
  ```
  
  ## Quality Standards
  
  ### Engine Quality Gates
  - **Separation**: Clean interface boundaries
  - **Performance**: Meet or exceed 60% improvement targets
  - **Reliability**: Graceful degradation on failure
  - **Maintainability**: Clear, documented logic
  - **Testing**: 100% method coverage
  
  ### Integration Standards
  - **Template Compatibility**: Works with existing templates
  - **Index Compliance**: Follows index specifications
  - **System Integration**: Seamless loading and caching
  - **Error Handling**: No system crashes from engine failure
  
  ## Documentation Requirements
  
  ### Implementation Documentation
  ```yaml
  required_docs:
    - implementation_guide: "How to implement this engine type"
    - integration_examples: "Working examples of integration"
    - performance_benchmarks: "Measured improvements"
    - testing_procedures: "How to validate engine functionality"
    - troubleshooting_guide: "Common issues and solutions"
  ```
  
  ## Success Metrics Template
  
  ### Performance Metrics
  - Memory usage reduction: ____%
  - Load time improvement: ____%
  - Execution speed: ___ms
  - Cache hit rate: ____%
  
  ### Quality Metrics
  - Test coverage: ____%
  - Error rate: ____%
  - Integration success: ____%
  - Developer satisfaction: ___/10
  
  ## Migration Guide Template
  
  ### From Static to Engine
  1. **Identify static component** requiring dynamic behavior
  2. **Extract rules** to index file
  3. **Create engine** using this template
  4. **Implement methods** following proven patterns
  5. **Test integration** with existing templates
  6. **Measure improvements** against targets
  7. **Document lessons learned**
  
  ---
  
  *Engine template based on successful Interactive Engine Architecture pattern*
  *Proven: 80% memory reduction, 70% performance improvement*
  *Pattern: Templates + Indices + Engines = Complete Executable Systems*

# TEMPLATE METADATA
metadata:
  created_from: "interactive-engine.md success pattern"
  performance_proven: "80% memory reduction, 70% speed improvement"
  pattern_foundation: "Templates + Indices + Engines"
  success_rate: "100% (1/1 implementations successful)"
  
  recommended_for:
    - "Menu systems"
    - "Workflow orchestration"
    - "Task execution"
    - "Validation systems"
    - "Agent interaction"
  
  complexity:
    implementation: "medium"
    integration: "low"
    maintenance: "low"
  
  dependencies:
    templates: "Component-specific templates"
    indices: "Component rule definitions"
    system: "Framework loading architecture"

# USAGE INSTRUCTIONS
usage:
  when_to_use: |
    Use this template when you have:
    - Declarative components that need executable behavior
    - Performance issues with monolithic implementations
    - Need for separation between structure and logic
    - Requirements for dynamic content population
  
  creation_steps:
    1: "Copy this template"
    2: "Replace all {{VARIABLES}} with actual values"
    3: "Implement the required methods"
    4: "Test integration with templates and indices"
    5: "Measure performance improvements"
    6: "Document implementation details"
  
  integration_checklist:
    - "[ ] Templates reference engine via engine_id"
    - "[ ] Indices contain rules for engine execution"
    - "[ ] Engine implements all required methods"
    - "[ ] Error handling and fallbacks configured"
    - "[ ] Performance targets met"
    - "[ ] Documentation complete"